/*
 * pwm.c
 *
 * Created: 2015-07-05 5:39:37 PM
 *  Author: David
 */ 

#define F_CPU 14745600UL
#include <util/delay.h>
#include <avr/io.h>
#include <avr/interrupt.h>
#include <stdio.h>
#include <stdlib.h>

static int uart_putchar(char c, FILE *stream);
static int uart_getchar(FILE *stream);
FILE mystdout = FDEV_SETUP_STREAM(uart_putchar, NULL, _FDEV_SETUP_WRITE);
FILE mystdin = FDEV_SETUP_STREAM(NULL, uart_getchar, _FDEV_SETUP_READ);

static int uart_putchar(char c, FILE *stream)
{
	loop_until_bit_is_set(UCSR0A, UDRE0);
	UDR0 = c;
	return 0;
}
static int uart_getchar(FILE *stream)
{
	loop_until_bit_is_set(UCSR0A, RXC0); /* Wait until data exists. */
	return UDR0;
}
void init_uart(void)
{
	UCSR0B = (1<<RXEN0) | (1<<TXEN0);
	UBRR0 = 7;
	stdout = &mystdout;
	stdin = &mystdin;
}

void _pwm_init(void);

void _pwm_fwd(int speed);
void _pwm_rvs(int speed);

void _pwm_brake(void);

void _pwm_LEFT_90(int speed);
void _pwm_RIGHT_90(int speed);

void R_BRAKE(void);
void L_BRAKE(void);

void R_MOTOR_CW(int speed);
void L_MOTOR_CW(int speed);

void R_MOTOR_CCW(int speed);
void L_MOTOR_CCW(int speed);


#define _FAST 200
#define _NORMAL 128
#define _SLOW 64

int main(void)
{
	init_uart();
	printf(("System Booted, built %s on %s\n"), __TIME__, __DATE__);
	_delay_ms(3000);
	int speed = 128;
	_delay_ms(3000);
	_pwm_init();
	//_delay_ms(5000);
	
	//RIGHT MOTOR TEST
	/*R_BRAKE();
	_delay_ms(3000);
	
	R_MOTOR_CW(speed);
	_delay_ms(3000);
	
	R_BRAKE();
	_delay_ms(3000);
	
	R_MOTOR_CCW(speed);
	_delay_ms(3000);
	
	R_BRAKE();
	_delay_ms(3000);*/
	
	//LEFT MOTOR TEST
	L_BRAKE();
	_delay_ms(3000);
	
	L_MOTOR_CW(speed);
	_delay_ms(3000);
	
	L_BRAKE();
	_delay_ms(3000);
	
	L_MOTOR_CCW(speed);
	_delay_ms(3000);
	
	L_BRAKE();
	_delay_ms(3000);
	
	
	
	//BRAKE
	/*//setting pb1 and 2 HIGH
	OCR0A = 0;
	OCR0B = 0;
	PORTB |=(1<<PB2);								// PB2	RIGHT (speed)						
	PORTB |=(1<<PB1);								// PB1	LEFT (speed)
	_delay_ms(5000);*/
	//RIGHT MOTOR CCW
	/*OCR0A = 128;									// PB3	RIGHT (speed)
	OCR0B = 128;									// PB4	LEFT(speed)
	//seting pb1 and 2 LOW
	PORTB &= ~(1<<PB2);									// PB3
	PORTB &= ~(1<<PB1);
	_delay_ms(10000);*/									
	//BRAKE
	/*//_delay_ms(5000);
	OCR0A = 0;											// PB3	RIGHT (speed)
	//OCR0B = 0;											// PB4	Left (speed)
	PORTB |=(1<<PB2);
	//PORTB |=(1<<PB1);
	//_delay_ms(5000);*/
	
	while(1);
}

void _pwm_init(void)
{
	//setting PORTB as output
	//DDRB |= (_BV(PB2) | _BV(PB3));					//RIGHT MOTOR	
	DDRB |= (_BV(PB1) | _BV(PB4));					//LEFT MOTOR							
	
	//_BV(PB1| _BV(PB4));												
	//DDRB |=_BV(PB1)|_BV(PB2);												
	
	PORTB = 0xFF;															//initialized PORTB all zeros		//don't you mean 1's?
	
	//set duty cycle
	OCR0A = 128;										// PB3	RIGHT												
	//OCR0B = 128;										// PB4	LEFT
	
	TCCR0A |= _BV(COM0A1)|_BV(COM0A0)| _BV(WGM00) |_BV(COM0B1)|_BV(COM0B0);	//phase correct pwm; inverting
    TCCR0B = 1<<CS01;														//pre-scaler of 8 
}

void _pwm_fwd(int speed)
{
	//set duty cycle
	OCR0A = speed;										// PB3	RIGHT																						
	OCR0B = speed;										// PB4	LEFT	
	PORTB |=(_BV(PB2));
	PORTB |=(_BV(PB1));
}
void _pwm_rvs(int speed)
{
	//set duty cycle
	OCR0A = speed;										// PB3	RIGHT												
	OCR0B = speed;										// PB4	RIGHT
	PORTB &= ~(1<<PB2);
	PORTB &= ~(1<<PB1);
}

void _pwm_brake(void)
{
	//set duty cycle
	OCR0A = 0;															
	OCR0B = 0;
	PORTB |=(1<<PB2);
	PORTB |=(1<<PB1);
}

void _pwm_LEFT_90(int speed)
{
	//set duty cycle
	OCR0A = 0;
	OCR0B = speed;
	PORTB |= (1<<PB2);
	PORTB |= (1<<PB1);
}
void _pwm_RIGHT_90(int speed)
{
	//set duty cycle
	OCR0B = 0;
	OCR0A  = speed;
	PORTB |= (1<<PB2);
	PORTB |= (1<<PB1);
}

void R_BRAKE()
{
	OCR0A = 0;
	PORTB |=(1<<PB2);								// PB2	RIGHT (speed)	
}
void R_MOTOR_CW(int speed)
{
	OCR0A = speed;									//PWM
	PORTB |=(1<<PB2);
}
void R_MOTOR_CCW(int speed)
{
	OCR0A = speed;									//PWM
	PORTB &= ~(1<<PB2);
}

void L_BRAKE()
{
	OCR0B = 0;
	PORTB |=(1<<PB1);
}
void L_MOTOR_CW(int speed)
{
	OCR0B = speed;
	PORTB |= (1<<PB1);
}
void L_MOTOR_CCW(int speed)
{
	OCR0B = speed;	
	PORTB &= ~(1<<PB1);
}
	
